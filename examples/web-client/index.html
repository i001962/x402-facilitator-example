<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>X402 Web Client - Real Payments</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }
      .container {
        background: white;
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      .header {
        text-align: center;
        margin-bottom: 30px;
      }
      .wallet-section {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
      }
      .api-section {
        background: #e3f2fd;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
      }
      .premium-section {
        background: #fff3e0;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
      }
      button {
        background: #1976d2;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 16px;
        margin: 5px;
        transition: background-color 0.2s;
      }
      button:hover {
        background: #1565c0;
      }
      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      .connect-btn {
        background: #4caf50;
      }
      .connect-btn:hover {
        background: #45a049;
      }
      .premium-btn {
        background: #ff9800;
      }
      .premium-btn:hover {
        background: #f57c00;
      }
      .status {
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
      }
      .status.success {
        background: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }
      .status.error {
        background: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }
      .status.info {
        background: #d1ecf1;
        color: #0c5460;
        border: 1px solid #bee5eb;
      }
      .status.warning {
        background: #fff3cd;
        color: #856404;
        border: 1px solid #ffeaa7;
      }
      .result {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 4px;
        margin: 10px 0;
        border-left: 4px solid #007bff;
        white-space: pre-wrap;
        font-family: monospace;
        font-size: 14px;
      }
      .wallet-info {
        display: none;
        background: #e8f5e8;
        padding: 15px;
        border-radius: 6px;
        margin: 10px 0;
      }
      .wallet-info.show {
        display: block;
      }
      .payment-info {
        background: #fff3e0;
        padding: 15px;
        border-radius: 6px;
        margin: 10px 0;
        border-left: 4px solid #ff9800;
      }
      .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid #f3f3f3;
        border-top: 3px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 10px;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üöÄ X402 Web Client - Real Payments</h1>
        <p>Connect your wallet to make real payments for API access</p>
      </div>

      <!-- Wallet Connection Section -->
      <div class="wallet-section">
        <h3>üîó Wallet Connection</h3>
        <button id="connectWallet" class="connect-btn">Connect MetaMask</button>
        <button id="disconnectWallet" style="display: none">Disconnect</button>

        <div id="walletInfo" class="wallet-info">
          <strong>Connected:</strong> <span id="walletAddress"></span><br />
          <strong>Network:</strong> <span id="walletNetwork"></span><br />
          <strong>Balance:</strong> <span id="walletBalance"></span>
        </div>
      </div>

      <!-- API Configuration -->
      <div class="api-section">
        <h3>‚öôÔ∏è API Configuration</h3>
        <div>
          <label for="apiUrl">Provider Server URL: </label>
          <input
            type="text"
            id="apiUrl"
            value="http://localhost:3001"
            style="width: 300px; padding: 8px"
          />
        </div>
        <div id="apiStatus" class="status info" style="display: none">API server is reachable</div>
      </div>

      <!-- Free API Endpoints -->
      <div class="api-section">
        <h3>üÜì Free Endpoints</h3>
        <button id="testHealth">Test Health Check</button>
        <div id="healthResult"></div>
      </div>

      <!-- Paid API Endpoints -->
      <div class="api-section">
        <h3>üí∞ Paid Endpoints (Real Payments)</h3>
        <button id="testWeather" disabled>Get Weather ($0.001)</button>
        <button id="testData" disabled>Process Data ($0.005)</button>
        <div id="paidResult"></div>
      </div>

      <!-- Premium Endpoints -->
      <div class="premium-section">
        <h3>üíé Premium Endpoints</h3>
        <button id="testPremium" disabled class="premium-btn">Premium Analytics (1 USDC)</button>
        <div id="premiumResult"></div>
      </div>

      <!-- Payment Status -->
      <div id="paymentStatus" class="status" style="display: none"></div>
    </div>

    <!-- Viem-powered wallet integration -->
    <script type="module">
      import {
        createPublicClient,
        createWalletClient,
        http,
        custom,
        getAddress,
        parseEther,
        formatEther,
      } from "https://esm.sh/viem@2.21.0";
      import { mainnet, base, baseSepolia } from "https://esm.sh/viem@2.21.0/chains";
      class X402WebClient {
        constructor() {
          this.account = null;
          this.network = null;
          this.isConnected = false;
          this.publicClient = null;
          this.walletClient = null;
          this.setupEventListeners();
          this.checkExistingConnection();
        }

        async checkExistingConnection() {
          // Check if wallet is already connected
          if (window.ethereum) {
            try {
              const accounts = await window.ethereum.request({
                method: "eth_accounts",
              });

              if (accounts.length > 0) {
                console.log("Found existing connection:", accounts[0]);
                this.account = getAddress(accounts[0]);
                const chainId = await window.ethereum.request({ method: "eth_chainId" });
                this.network = this.getNetworkName(chainId);
                this.ethereum = window.ethereum;

                // Initialize viem clients for existing connection
                const chain = this.getViemChain(chainId);
                this.publicClient = createPublicClient({
                  chain,
                  transport: http(),
                });

                this.walletClient = createWalletClient({
                  chain,
                  transport: custom(window.ethereum),
                  account: this.account,
                });

                this.isConnected = true;
                this.updateUI();
                await this.updateWalletInfo(this.account, this.network);
              }
            } catch (error) {
              console.log("No existing connection found");
            }
          }
        }

        setupEventListeners() {
          console.log("Setting up event listeners...");

          document.getElementById("connectWallet").addEventListener("click", () => {
            console.log("Connect wallet clicked");
            this.connectWallet();
          });
          document.getElementById("disconnectWallet").addEventListener("click", () => {
            console.log("Disconnect wallet clicked");
            this.disconnectWallet();
          });
          document.getElementById("testHealth").addEventListener("click", () => {
            console.log("Test health clicked");
            this.testHealth();
          });
          document.getElementById("testWeather").addEventListener("click", () => {
            console.log("Test weather clicked");
            this.testWeather();
          });
          document.getElementById("testData").addEventListener("click", () => {
            console.log("Test data clicked");
            this.testData();
          });
          document.getElementById("testPremium").addEventListener("click", () => {
            console.log("Test premium clicked");
            this.testPremium();
          });

          // Listen for network changes
          if (window.ethereum) {
            window.ethereum.on("chainChanged", chainId => {
              console.log("Network changed:", chainId);
              this.handleNetworkChange(chainId);
            });

            window.ethereum.on("accountsChanged", accounts => {
              console.log("Account changed:", accounts);
              if (accounts.length > 0 && this.isConnected) {
                this.account = accounts[0];
                this.updateWalletInfo(this.account, this.getNetworkName());
              } else if (accounts.length === 0) {
                this.disconnectWallet();
              }
            });
          }
        }

        async connectWallet() {
          try {
            console.log("Starting wallet connection...");
            this.showStatus("Connecting to MetaMask...", "info");

            // Check if MetaMask is installed
            if (typeof window.ethereum === "undefined") {
              throw new Error("MetaMask is not installed. Please install MetaMask to continue.");
            }

            console.log("MetaMask detected, requesting accounts...");

            // Request account access - this should open MetaMask
            const accounts = await window.ethereum.request({
              method: "eth_requestAccounts",
            });

            console.log("Accounts received:", accounts);

            if (accounts.length === 0) {
              throw new Error("No accounts found. Please connect your wallet.");
            }

            this.account = getAddress(accounts[0]);
            console.log("Account set:", this.account);

            // Get current network from MetaMask
            const chainId = await window.ethereum.request({ method: "eth_chainId" });
            console.log("Current Chain ID:", chainId);
            this.network = this.getNetworkName(chainId);

            // Check if we need to switch networks
            const expectedChainId = this.getExpectedChainId();
            const expectedHexChainId = `0x${expectedChainId.toString(16)}`;
            console.log("Expected Chain ID:", expectedChainId, "Expected Hex:", expectedHexChainId);

            if (chainId !== expectedHexChainId) {
              console.log("Switching to correct network...");
              await this.switchToCorrectNetwork(expectedChainId);
              // Get the updated chainId after switching
              const newChainId = await window.ethereum.request({ method: "eth_chainId" });
              console.log("New Chain ID after switch:", newChainId);
              this.network = this.getNetworkName(newChainId);
            }

            // Create viem clients
            const currentChainId = await window.ethereum.request({ method: "eth_chainId" });
            const chain = this.getViemChain(currentChainId);
            this.publicClient = createPublicClient({
              chain,
              transport: http(),
            });

            this.walletClient = createWalletClient({
              chain,
              transport: custom(window.ethereum),
              account: this.account,
            });

            this.isConnected = true;
            this.updateUI();
            this.showStatus("Wallet connected successfully!", "success");

            // Get wallet info
            await this.updateWalletInfo(this.account, this.network);
            console.log("Wallet connection completed successfully");
          } catch (error) {
            console.error("Wallet connection error:", error);
            this.showStatus(`Connection failed: ${error.message}`, "error");
            this.isConnected = false;
            this.updateUI();
          }
        }

        async disconnectWallet() {
          this.account = null;
          this.network = null;
          this.isConnected = false;
          this.ethereum = null;
          this.updateUI();
          this.showStatus("Wallet disconnected", "info");
        }

        updateUI() {
          const connectBtn = document.getElementById("connectWallet");
          const disconnectBtn = document.getElementById("disconnectWallet");
          const walletInfo = document.getElementById("walletInfo");
          const paidButtons = document.querySelectorAll("#testWeather, #testData, #testPremium");

          if (this.isConnected) {
            connectBtn.style.display = "none";
            disconnectBtn.style.display = "inline-block";
            walletInfo.classList.add("show");
            paidButtons.forEach(btn => (btn.disabled = false));
          } else {
            connectBtn.style.display = "inline-block";
            disconnectBtn.style.display = "none";
            walletInfo.classList.remove("show");
            paidButtons.forEach(btn => (btn.disabled = true));
          }
        }

        async updateWalletInfo(address, network) {
          document.getElementById("walletAddress").textContent = address;
          document.getElementById("walletNetwork").textContent = network;

          try {
            // Get balance using viem
            const balance = await this.publicClient.getBalance({
              address: address,
            });
            const balanceEth = parseFloat(formatEther(balance)).toFixed(4);

            // Determine token symbol based on network
            let tokenSymbol = "ETH";
            if (network.includes("Base")) {
              tokenSymbol = "ETH";
            } else if (network.includes("Polygon")) {
              tokenSymbol = "MATIC";
            }

            document.getElementById("walletBalance").textContent = `${balanceEth} ${tokenSymbol}`;
          } catch (error) {
            document.getElementById("walletBalance").textContent = "Unable to fetch";
          }
        }

        async handleNetworkChange(chainId) {
          if (!this.isConnected) return;

          const networkName = this.getNetworkName(chainId);
          this.network = networkName;

          // Update ethereum reference
          this.ethereum = window.ethereum;

          // Update the UI with new network info
          document.getElementById("walletNetwork").textContent = networkName;

          // Update balance for the new network
          if (this.account) {
            await this.updateWalletInfo(this.account, networkName);
          }

          this.showStatus(`Network changed to ${networkName}`, "info");
        }

        getNetworkName(chainId = null) {
          if (!chainId && window.ethereum) {
            chainId = window.ethereum.chainId;
          }

          const networkMap = {
            "0x1": "Ethereum Mainnet",
            "0xaa36a7": "Sepolia Testnet",
            "0xa": "Base Mainnet",
            "0x2105": "Base Mainnet",
            "0x14a33": "Base Sepolia (Testnet)",
            "0x89": "Polygon Mainnet",
            "0x13881": "Polygon Mumbai",
          };

          return networkMap[chainId] || `Unknown Network (${chainId})`;
        }

        getChainFromId(chainId) {
          const chainMap = {
            "0x1": { id: 1, name: "Ethereum Mainnet" },
            "0xaa36a7": { id: 11155111, name: "Sepolia Testnet" },
            "0xa": { id: 10, name: "Base Mainnet" },
            "0x2105": { id: 8453, name: "Base Mainnet" },
            "0x14a33": { id: 84532, name: "Base Sepolia" },
            "0x89": { id: 137, name: "Polygon Mainnet" },
            "0x13881": { id: 80001, name: "Polygon Mumbai" },
          };

          return chainMap[chainId] || { id: 84532, name: "Base Sepolia" };
        }

        async testHealth() {
          try {
            const apiUrl = document.getElementById("apiUrl").value;
            const response = await fetch(`${apiUrl}/health`);
            const data = await response.json();

            document.getElementById("healthResult").innerHTML =
              `<div class="result">${JSON.stringify(data, null, 2)}</div>`;

            document.getElementById("apiStatus").style.display = "block";
            document.getElementById("apiStatus").className = "status success";
            document.getElementById("apiStatus").textContent = "API server is reachable";
          } catch (error) {
            document.getElementById("healthResult").innerHTML =
              `<div class="result">Error: ${error.message}</div>`;

            document.getElementById("apiStatus").style.display = "block";
            document.getElementById("apiStatus").className = "status error";
            document.getElementById("apiStatus").textContent = "API server is not reachable";
          }
        }

        async testWeather() {
          console.log("testWeather called, isConnected:", this.isConnected);

          if (!this.isConnected) {
            this.showStatus("Please connect your wallet first", "error");
            return;
          }

          try {
            this.showStatus("Making payment and requesting weather data...", "info");
            const apiUrl = document.getElementById("apiUrl").value;
            console.log("API URL:", apiUrl);

            // Make the request and handle 402 responses
            const response = await this.makePaymentRequest(`${apiUrl}/weather`);
            console.log("Response status:", response.status);

            if (response.ok) {
              const data = await response.json();
              document.getElementById("paidResult").innerHTML =
                `<div class="result">Weather Data:\n${JSON.stringify(data, null, 2)}</div>`;
              this.showStatus("Payment successful! Weather data received.", "success");
            } else {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
          } catch (error) {
            console.error("testWeather error:", error);
            this.showStatus(`Request failed: ${error.message}`, "error");
            document.getElementById("paidResult").innerHTML =
              `<div class="result">Error: ${error.message}</div>`;
          }
        }

        async testData() {
          if (!this.isConnected) {
            this.showStatus("Please connect your wallet first", "error");
            return;
          }

          try {
            this.showStatus("Making payment and processing data...", "info");
            const apiUrl = document.getElementById("apiUrl").value;

            const response = await this.makePaymentRequest(`${apiUrl}/api/data`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                data: "test data",
                timestamp: new Date().toISOString(),
              }),
            });

            if (response.ok) {
              const data = await response.json();
              document.getElementById("paidResult").innerHTML =
                `<div class="result">Data Processing Result:\n${JSON.stringify(data, null, 2)}</div>`;
              this.showStatus("Payment successful! Data processed.", "success");
            } else {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
          } catch (error) {
            this.showStatus(`Request failed: ${error.message}`, "error");
            document.getElementById("paidResult").innerHTML =
              `<div class="result">Error: ${error.message}</div>`;
          }
        }

        async testPremium() {
          if (!this.isConnected) {
            this.showStatus("Please connect your wallet first", "error");
            return;
          }

          try {
            this.showStatus("Making premium payment...", "info");
            const apiUrl = document.getElementById("apiUrl").value;

            const response = await this.makePaymentRequest(`${apiUrl}/premium/analytics`);

            if (response.ok) {
              const data = await response.json();
              document.getElementById("premiumResult").innerHTML =
                `<div class="result">Premium Analytics:\n${JSON.stringify(data, null, 2)}</div>`;
              this.showStatus("Premium payment successful!", "success");
            } else {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
          } catch (error) {
            this.showStatus(`Premium request failed: ${error.message}`, "error");
            document.getElementById("premiumResult").innerHTML =
              `<div class="result">Error: ${error.message}</div>`;
          }
        }

        async makePaymentRequest(url, options = {}) {
          console.log("makePaymentRequest called with URL:", url);

          // First, try the request without payment
          let response = await fetch(url, options);
          console.log("Initial response status:", response.status);

          if (response.status !== 402) {
            console.log("Not a 402 response, returning directly");
            return response;
          }

          // Got 402 Payment Required, parse the payment requirements
          const paymentInfo = await response.json();
          console.log("Payment required:", paymentInfo);

          // Show payment info to user
          this.showPaymentInfo(paymentInfo);

          // Ask user to confirm payment
          const confirmed = await this.confirmPayment(paymentInfo);
          console.log("Payment confirmed:", confirmed);
          if (!confirmed) {
            throw new Error("Payment cancelled by user");
          }

          // Process the payment
          this.showStatus("Processing payment...", "info");

          try {
            // Ensure we're on the correct network before signing
            const currentChainId = await window.ethereum.request({ method: "eth_chainId" });
            const expectedChainId = this.getExpectedChainId();
            const expectedHexChainId = `0x${expectedChainId.toString(16)}`;

            console.log("Current chainId:", currentChainId, "Expected:", expectedHexChainId);

            if (currentChainId !== expectedHexChainId) {
              this.showStatus("Switching to correct network...", "info");
              await this.switchToCorrectNetwork(expectedChainId);
              // Update our network info after switching
              const newChainId = await window.ethereum.request({ method: "eth_chainId" });
              this.network = this.getNetworkName(newChainId);
              this.updateUI();
            }

            // Create EIP-3009 authorization signature
            this.showStatus("Please sign the payment authorization in MetaMask...", "info");
            const authorization = await this.createAuthorizationSignature(paymentInfo);

            // Create payment proof with authorization
            const paymentProof = await this.createPaymentProof(authorization, paymentInfo);

            // Retry the request with payment header
            const newOptions = {
              ...options,
              headers: {
                ...(options.headers || {}),
                "X-PAYMENT": paymentProof,
              },
            };

            this.showStatus("Payment submitted, retrying request...", "info");
            console.log("Retrying with payment header:", newOptions.headers["X-PAYMENT"]);
            response = await fetch(url, newOptions);

            if (response.ok) {
              this.showStatus("Payment successful! Request completed.", "success");
            } else {
              throw new Error(`Payment failed: ${response.status} ${response.statusText}`);
            }

            return response;
          } catch (error) {
            this.showStatus(`Payment failed: ${error.message}`, "error");
            throw error;
          }
        }

        showPaymentInfo(paymentInfo) {
          const accepts = paymentInfo.accepts[0];
          const amount = (parseInt(accepts.maxAmountRequired) / 1000000).toFixed(6); // USDC has 6 decimals

          const paymentDiv = document.createElement("div");
          paymentDiv.className = "payment-info";
          paymentDiv.innerHTML = `
            <h4>üí≥ Payment Required</h4>
            <p><strong>Amount:</strong> ${amount} USDC</p>
            <p><strong>Network:</strong> ${accepts.network}</p>
            <p><strong>Pay To:</strong> ${accepts.payTo}</p>
            <p><strong>Asset:</strong> ${accepts.extra.name}</p>
          `;

          // Insert after the current result
          const resultDiv = document.getElementById("paidResult");
          resultDiv.appendChild(paymentDiv);
        }

        async confirmPayment(paymentInfo) {
          const accepts = paymentInfo.accepts[0];
          const amount = (parseInt(accepts.maxAmountRequired) / 1000000).toFixed(6);

          return new Promise(resolve => {
            const confirmed = confirm(
              `Confirm Payment\n\n` +
                `Amount: ${amount} USDC\n` +
                `Network: ${accepts.network}\n` +
                `Pay To: ${accepts.payTo}\n\n` +
                `Click OK to proceed with payment, or Cancel to abort.`,
            );
            resolve(confirmed);
          });
        }

        async createAuthorizationSignature(paymentInfo) {
          const accepts = paymentInfo.accepts[0];
          const amount = accepts.maxAmountRequired;
          const payToAddress = accepts.payTo;
          const assetAddress = accepts.asset;
          const network = accepts.network;

          console.log("Creating EIP-3009 authorization:", {
            amount,
            payToAddress,
            assetAddress,
            network,
          });

          // Generate authorization parameters
          const now = Math.floor(Date.now() / 1000);
          const validAfter = now;
          const validBefore = now + 300; // 5 minutes validity
          const nonce = this.generateNonce();

          const authorization = {
            from: this.account,
            to: payToAddress,
            value: amount,
            validAfter: validAfter.toString(),
            validBefore: validBefore.toString(),
            nonce: nonce,
          };

          console.log("Authorization parameters:", authorization);

          // Create EIP-712 typed data for EIP-3009 TransferWithAuthorization
          // This must match exactly what the x402 library expects (only TransferWithAuthorization type)
          const typedData = {
            types: {
              TransferWithAuthorization: [
                { name: "from", type: "address" },
                { name: "to", type: "address" },
                { name: "value", type: "uint256" },
                { name: "validAfter", type: "uint256" },
                { name: "validBefore", type: "uint256" },
                { name: "nonce", type: "bytes32" },
              ],
            },
            primaryType: "TransferWithAuthorization",
            domain: {
              name: accepts.extra.name, // "USD Coin"
              version: accepts.extra.version, // "2"
              chainId: this.getChainId(network),
              verifyingContract: assetAddress,
            },
            message: {
              from: this.account,
              to: payToAddress,
              value: amount,
              validAfter: validAfter.toString(),
              validBefore: validBefore.toString(),
              nonce: nonce,
            },
          };

          console.log("EIP-712 typed data:", typedData);

          // Sign the typed data with viem
          console.log("About to sign with wallet client:", this.walletClient);
          console.log("Account:", this.account);
          const signature = await this.walletClient.signTypedData(typedData);

          console.log("Authorization signature:", signature);

          return {
            signature,
            authorization,
          };
        }

        async createPaymentProof(authorization, paymentInfo) {
          const accepts = paymentInfo.accepts[0];

          // Create x402 payment header according to the specification
          const paymentHeader = {
            x402Version: 1,
            scheme: "exact",
            network: accepts.network,
            payload: {
              signature: authorization.signature,
              authorization: authorization.authorization,
            },
          };

          console.log("Payment header:", paymentHeader);

          // Encode as base64 for X-PAYMENT header
          return btoa(JSON.stringify(paymentHeader));
        }

        generateNonce() {
          // Generate a random 32-byte nonce
          const array = new Uint8Array(32);
          crypto.getRandomValues(array);
          return "0x" + Array.from(array, byte => byte.toString(16).padStart(2, "0")).join("");
        }

        getChainId(network) {
          const chainIdMap = {
            "base-sepolia": 84532, // Base Sepolia
            base: 8453, // Base Mainnet
            ethereum: 1, // Ethereum Mainnet
            polygon: 137, // Polygon
          };
          return chainIdMap[network] || 1;
        }

        getViemChain(chainId) {
          const chainIdMap = {
            "0x1": mainnet,
            "0xa": base,
            "0x14a33": baseSepolia,
          };
          return chainIdMap[chainId] || mainnet;
        }

        getExpectedChainId() {
          // Get the expected chain ID from the provider server
          // For now, we'll use Base Mainnet (8453) as the default
          return 8453; // Base Mainnet
        }

        async switchToCorrectNetwork(expectedChainId) {
          try {
            const hexChainId = `0x${expectedChainId.toString(16)}`;
            console.log("Attempting to switch to chain:", hexChainId);

            // Try to switch to the correct network
            await window.ethereum.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: hexChainId }],
            });

            console.log("Successfully switched to correct network");

            // Update network info after switch
            const newChainId = await window.ethereum.request({ method: "eth_chainId" });
            this.network = this.getNetworkName(newChainId);

            // Recreate viem clients with new chain
            const chain = this.getViemChain(newChainId);
            this.publicClient = createPublicClient({
              chain,
              transport: http(),
            });

            this.walletClient = createWalletClient({
              chain,
              transport: custom(window.ethereum),
              account: this.account,
            });

            // Update UI
            await this.updateWalletInfo(this.account, this.network);
          } catch (error) {
            console.error("Failed to switch network:", error);

            // If the network doesn't exist, try to add it
            if (error.code === 4902) {
              await this.addBaseMainnetNetwork();
            } else {
              throw new Error(`Failed to switch to Base Mainnet: ${error.message}`);
            }
          }
        }

        async addBaseMainnetNetwork() {
          try {
            await window.ethereum.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  chainId: "0xa",
                  chainName: "Base Mainnet",
                  nativeCurrency: {
                    name: "Ethereum",
                    symbol: "ETH",
                    decimals: 18,
                  },
                  rpcUrls: ["https://mainnet.base.org"],
                  blockExplorerUrls: ["https://basescan.org"],
                },
              ],
            });

            console.log("Successfully added Base Mainnet network");
            // Retry switching after adding
            await this.switchToCorrectNetwork("0xa");
          } catch (error) {
            console.error("Failed to add Base Mainnet network:", error);
            throw new Error("Please manually switch to Base Mainnet in MetaMask");
          }
        }

        showStatus(message, type) {
          const statusEl = document.getElementById("paymentStatus");
          statusEl.textContent = message;
          statusEl.className = `status ${type}`;
          statusEl.style.display = "block";

          // Auto-hide after 8 seconds for warnings, 5 seconds for others
          const timeout = type === "warning" ? 8000 : 5000;
          setTimeout(() => {
            statusEl.style.display = "none";
          }, timeout);
        }
      }

      // Initialize the client when the page loads
      const client = new X402WebClient();
    </script>
  </body>
</html>
